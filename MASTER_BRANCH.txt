ПОЛНЫЙ АНАЛИЗ СИСТЕМЫ СОХРАНЕНИЯ МИРА ULTRAMINE CORE

  1. АРХИТЕКТУРА СИСТЕМЫ СОХРАНЕНИЯ

  1.1 Компоненты верхнего уровня

  - RegionFile (RegionFile.java:17) - управление region-файлами (*.mca)
  - AnvilChunkLoader (AnvilChunkLoader.java:45) - загрузка/сохранение чанков в NBT
  - Chunk (Chunk.java:60) - основная структура чанка в памяти
  - ExtendedBlockStorage (ExtendedBlockStorage.java:15) - 16x16x16 секция блоков

  1.2 Система off-heap памяти

  - UnsafeChunkAlloc - аллокатор off-heap памяти для чанков
  - MemSlot - интерфейс для работы с блоками памяти
  - Unsafe7MemSlot и Unsafe8MemSlot - две реализации layouts

  ---
  2. ПОБИТОВЫЕ ОПЕРАЦИИ И СТРУКТУРА ДАННЫХ

  2.1 ChunkHash - Хеширование координат

  Chunk-to-Key (ChunkHash.java:5-8):
  int chunkToKey(int x, int z) {
      return (x & 0xffff) << 16 | (z & 0xffff);
  }
  - Байты: 4 байта (32 бита)
  - Структура: [X: 16 бит][Z: 16 бит]
  - Диапазон: -32768 до 32767 для X и Z

  Chunk Coord Hash (ChunkHash.java:19-22):
  short chunkCoordToHash(int x, int y, int z) {
      return (short)((y << 8) | (z << 4) | x);
  }
  - Байты: 2 байта (16 бит)
  - Структура: [Y: 4 бита][Z: 4 бита][X: 4 бита]
  - Диапазон: 0-15 для каждой координаты

  Block Coord Hash (ChunkHash.java:29-32):
  long blockCoordToHash(int x, int y, int z) {
      return (long)(x & 0xffffff) | ((long)(y & 0xff) << 24) | ((long)(z & 0xffffff) << 32);
  }
  - Байты: 8 байт (64 бита)
  - Структура: [Z: 24 бита][Y: 8 бит][X: 24 бита]

  ---
  3. MEMORY SLOT LAYOUTS

  3.1 Layout 7 (Default) - Unsafe7MemSlot.java

  Общий размер: 12288 байт (12 КБ)

  Offset | Size | Description
  -------|------|-------------
  0      | 4096 | Block IDs (LSB) - младшие 8 бит ID блока
  4096   | 2048 | Block IDs (MSB) - старшие 4 бита ID блока (упаковка 4-bit nibbles)
  6144   | 2048 | Metadata - метаданные блоков (4-bit nibbles)
  8192   | 2048 | Block Light - освещение от блоков (4-bit nibbles)
  10240  | 2048 | Sky Light - небесное освещение (4-bit nibbles)

  Индексация блока (Unsafe7MemSlot.java:191):
  // Получение Block ID
  index = y << 8 | z << 4 | x
  LSB = byte[index]                    // 8 бит
  MSB = nibble[index >> 1]             // 4 бита
  blockId = (LSB & 255) | (MSB << 8)   // 12 бит (0-4095)

  4-bit nibble операции (AbstractUnsafeMemSlot.java:75-90):
  int get4bits(int start, int x, int y, int z) {
      int ind = y << 8 | z << 4 | x;        // YZX индекс
      byte data = getByte(start + (ind >> 1)); // 2 значения на байт
      return (ind & 1) == 0 ? data & 15 : data >> 4 & 15;
  }
  - Формула индекса: ind = Y * 256 + Z * 16 + X
  - Упаковка: Два 4-битных значения в один байт
  - Четный индекс: младшие 4 бита (data & 0x0F)
  - Нечетный индекс: старшие 4 бита (data >> 4 & 0x0F)

  3.2 Layout 8 (Experimental) - Unsafe8MemSlot.java

  Общий размер: 12288 байт (12 КБ)

  Offset | Size | Description
  -------|------|-------------
  0      | 8192 | Block ID + Metadata (16-bit chars, 12 бит ID + 4 бита meta)
  8192   | 2048 | Block Light
  10240  | 2048 | Sky Light

  Структура 16-bit значения:
  [Meta: 4 бита][MSB: 4 бита][LSB: 8 бит]
  [15-12]       [11-8]         [7-0]

  Операции с Layout 8:
  // Получение Block ID (Unsafe8MemSlot.java:177)
  char data = getChar((y << 8 | z << 4 | x) << 1);
  int blockId = data & 0xFFF;  // Младшие 12 бит

  // Получение Metadata
  int meta = data >> 12;  // Старшие 4 бита

  ---
  4. REGION FILE FORMAT

  4.1 Структура Region File (RegionFile.java)

  Заголовок (8192 байта):
  Байты 0-4095:    Offsets таблица (1024 записи по 4 байта)
  Байты 4096-8191: Timestamps таблица (1024 записи по 4 байта)

  Offset Entry (4 байта):
  [Sector Offset: 24 бита][Sector Count: 8 бит]
  - Sector Offset: начало данных чанка (sector * 4096)
  - Sector Count: количество 4KB секторов
  - Извлечение: offset >> 8, count = offset & 255

  Индекс чанка в таблице (RegionFile.java:327-330):
  int index = chunkX + chunkZ * 32  // 0-1023 (32x32 чанков)

  4.2 Формат данных чанка

  Chunk Data Header (5 байт):
  [Length: 4 байта][Compression: 1 байт][Compressed Data...]

  Compression Types:
  - 1 = GZIP (не используется)
  - 2 = Deflate/Zlib (стандартный)

  Запись данных (RegionFile.java:314-320):
  void write(int sector, byte[] data, int length) {
      seek(sector * 4096);
      writeInt(length + 1);      // Length
      writeByte(2);              // Compression type (Deflate)
      write(data, 0, length);    // Compressed NBT data
  }

  4.3 RegionFileCache

  Кеширование (RegionFileCache.java:40-53):
  - Максимум 256 открытых region файлов
  - При переполнении - оставляем 128 новейших
  - LRU-подобная политика с timestamp tracking

  ---
  5. NBT СЕРИАЛИЗАЦИЯ

  5.1 Chunk NBT Structure (AnvilChunkLoader.java:334-459)

  Level {
      V: byte(1)
      xPos: int
      zPos: int
      LastUpdate: long
      HeightMap: int[256]
      TerrainPopulated: boolean
      LightPopulated: boolean
      InhabitedTime: long
      Sections: List<Section>
      Biomes: byte[256]
      Entities: List<Entity>
      TileEntities: List<TileEntity>
      TileTicks: List<PendingUpdate>
  }

  5.2 Section NBT (EbsSaveFakeNbt.java)

  Оптимизация: Fake NBT - не создает NBT-структуру до сериализации

  Прямая запись (EbsSaveFakeNbt.java:56-84):
  Y: byte                    // Section Y-level
  Blocks: byte[4096]         // LSB
  Add: byte[2048]            // MSB (nibbles)
  Data: byte[2048]           // Metadata (nibbles)
  BlockLight: byte[2048]     // Block light (nibbles)
  SkyLight: byte[2048]       // Sky light (nibbles)

  Размер секции:
  - Несжатый: ~12336 байт
  - После Deflate: ~200-2000 байт (зависит от содержимого)

  5.3 Compression

  Deflate Level (S21PacketChunkData.java:74):
  Deflater deflater = new Deflater(7);  // Уровень 7 (из 9)

  CompressedStreamTools - GZIP для файлов, Deflate для регионов:
  - NBT Tag Header: [Type: 1 байт][Name Length: 2 байта][Name: UTF-8]
  - Byte Array: [Type 7: 1 байт][Name][Length: 4 байта][Data]

  ---
  6. NETWORK PACKET FORMAT (S21PacketChunkData.java)

  Packet Structure:
  chunkX: int (4 байта)
  chunkZ: int (4 байта)
  continuous: boolean (1 байт)
  primaryBitMask: short (2 байта)  // Маска присутствующих секций
  addBitMask: short (2 байта)      // Маска MSB arrays
  dataSize: int (4 байта)
  data: byte[dataSize]             // Deflated chunk data

  Data Layout (до сжатия):
  For each section (bit set in mask):
      LSB[4096]
      Metadata[2048]
      BlockLight[2048]
      SkyLight[2048] (if !hasNoSky)
      MSB[2048] (if bit set in addBitMask)
  Biomes[256] (if continuous)

  Размер сетевого пакета:
  - Полный чанк: ~40-120 KB (после Deflate)
  - Одна секция: ~2-10 KB

  ---
  7. ПАМЯТЬ И ПРОИЗВОДИТЕЛЬНОСТЬ

  7.1 Off-Heap Allocation

  Лимит памяти (UnsafeChunkAlloc.java:27):
  // По умолчанию: 6 GB / 12288 bytes = ~524,288 слотов
  int SLOT_LIMIT = 6 * (1024 * 1024 * 1024 / SLOT_SIZE);

  Кеширование слотов (UnsafeChunkAlloc.java:29):
  static final int SLOT_FREE_DELAY = 5000; // 5 секунд
  - Отложенное освобождение для защиты от race conditions
  - Переиспользование освобожденных слотов

  7.2 Размеры на чанк

  В памяти (один Chunk):
  - 16 секций × 12KB = 192 KB (максимум)
  - Реальный: 50-150 KB (зависит от заполненности)
  - HeightMap: 256 × 4 = 1 KB
  - Biomes: 256 байт
  - Entity/TileEntity lists: переменно

  На диске (Region File):
  - Несжатый: ~200-500 KB
  - После Deflate: ~20-100 KB (средний: 40 KB)
  - Region (32×32 чанков): 8 KB header + ~40 MB данных (макс)

  7.3 Побитовые маски в производительности

  Section Mask - битовая маска для 16 секций:
  // Проверка наличия секции Y (0-15)
  if ((sectionMask & (1 << y)) != 0) {
      // Секция присутствует
  }

  Преимущества:
  - 16-bit маска = 2 байта вместо 16 boolean
  - Быстрые битовые операции вместо массивов
  - Удобная передача по сети

  ---
  8. КРИТИЧЕСКИЕ ПОБИТОВЫЕ ОПЕРАЦИИ

  8.1 Индексация координат

  3D → 1D индекс (Y-Z-X ordering):
  index = y << 8 | z << 4 | x
  // Эквивалентно: y * 256 + z * 16 + x
  // Диапазон: 0-4095 (для 16×16×16)

  Обратное преобразование:
  x = index & 0xF          // Младшие 4 бита
  z = (index >> 4) & 0xF   // Биты 4-7
  y = (index >> 8) & 0xF   // Биты 8-11

  8.2 Nibble Array Packing

  Упаковка 4-битных значений:
  // Сохранение
  if ((index & 1) == 0)
      data[index >> 1] = (data[index >> 1] & 0xF0) | (value & 0x0F);
  else
      data[index >> 1] = (data[index >> 1] & 0x0F) | ((value & 0x0F) << 4);

  // Извлечение
  value = ((index & 1) == 0) ? (data[index >> 1] & 0x0F) : (data[index >> 1] >> 4 & 0x0F);

  Экономия: 50% памяти (2048 вместо 4096 байт)

  8.3 Block ID Storage

  12-битный Block ID (поддержка 4096 блоков):
  Layout 7: LSB[8 бит] + MSB[4 бита] (раздельно)
  Layout 8: Единый 12-битный в char[16 бит]

  Извлечение (Layout 7):
  int blockId = (lsb[index] & 0xFF) | (getMSBNibble(index) << 8);

  Извлечение (Layout 8):
  char packed = getChar(index * 2);
  int blockId = packed & 0xFFF;
  int meta = packed >> 12;

  ---
  9. КЛЮЧЕВЫЕ КОНСТАНТЫ

  CHUNK_SIZE = 16x16x256 blocks
  SECTION_SIZE = 16x16x16 blocks = 4096 blocks
  REGION_SIZE = 32x32 chunks = 1024 chunks
  SECTOR_SIZE = 4096 bytes

  // Memory Slot
  SLOT_SIZE_LAYOUT7 = 12288 bytes (12 KB)
  SLOT_SIZE_LAYOUT8 = 12288 bytes (12 KB)

  // Arrays per section
  LSB_ARRAY = 4096 bytes (Block IDs низ)
  MSB_ARRAY = 2048 bytes (Block IDs верх, nibbles)
  META_ARRAY = 2048 bytes (Metadata, nibbles)
  BLOCKLIGHT_ARRAY = 2048 bytes (Block Light, nibbles)
  SKYLIGHT_ARRAY = 2048 bytes (Sky Light, nibbles)

  // Region File
  REGION_HEADER = 8192 bytes
  CHUNK_TABLE_SIZE = 1024 entries × 4 bytes = 4096 bytes
  TIMESTAMP_TABLE_SIZE = 1024 entries × 4 bytes = 4096 bytes

  // Compression
  DEFLATE_LEVEL = 7
  COMPRESSION_TYPE_GZIP = 1
  COMPRESSION_TYPE_DEFLATE = 2

  ---
  10. ВЫВОДЫ

  10.1 Оптимизации проекта

  1. Off-heap память - устранение GC overhead для чанков
  2. Fake NBT - ленивая сериализация, прямая запись байтов
  3. Два Layout - выбор между скоростью (Layout 7) и плотностью (Layout 8)
  4. Reference counting - контроль времени жизни ExtendedBlockStorage
  5. Битовые маски - компактное представление флагов секций

  10.2 Побитовая магия

  - Все 4-битные данные (meta, light, MSB) упакованы в nibbles - 50% экономия
  - Координаты упакованы в int/short/long через битовые сдвиги - O(1) хеш
  - Layout 8 пакует ID+meta в один char - атомарный доступ
  - Region offset table использует 24+8 бит - компактный индекс

  10.3 Размер данных на чанк

  Минимальный (пустой):
  - В памяти: ~5 KB (структуры)
  - На диске: ~500 байт (NBT + сжатие)

  Типичный (частично заполненный):
  - В памяти: 50-100 KB
  - На диске: 20-40 KB

  Максимальный (16 полных секций):
  - В памяти: 192 KB + overhead
  - На диске: 80-120 KB

  Система оптимизирована для массового хранения с минимальным влиянием на GC и максимальной скоростью доступа к блокам.